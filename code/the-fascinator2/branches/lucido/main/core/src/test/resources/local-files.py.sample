import time
from au.edu.usq.fascinator.indexer.rules import AddField, New
from org.dom4j.io import SAXReader

from au.edu.usq.fascinator.common.nfo import PaginatedTextDocument
from au.edu.usq.fascinator.common.nco import Contact
from au.edu.usq.fascinator.common.nie import InformationElement

#
# Available objects:
#    indexer   : Indexer instance
#    rules     : RuleManager instance
#    object    : DigitalObject to index
#    payloadId : Payload identifier
#    storageId : Storage layer identifier
#

def indexing(names, values):
    for value in values:
        for name in names:
            rules.add(AddField(name, value))

def getNodeValues (doc, xPath):
    nodes = doc.selectNodes(xPath)
    valueList = []
    if nodes:
        for node in nodes:
            #remove duplicates:
            nodeValue = node.getText()
            if nodeValue not in valueList:
                valueList.append(node.getText())
    return valueList 

rules.add(New())

if isMetadata:
    solrId = object.getId();
    itemType = "object"
else:
    solrId = object.getId() + "/" + payloadId
    itemType = "datastream"
    rules.add(AddField("identifier", payloadId))

# path
path = object.getId().replace("\\", "/")
parts = path.split("/")
for i in range(1, len(parts)):
    part = "/".join(parts[:i])
    if part != "":
        if part.startswith("/"):
            part = part[1:]
        rules.add(AddField("file_path", part))

rules.add(AddField("id", solrId))
rules.add(AddField("last_modified", time.strftime("%Y-%m-%dT%H:%M:%SZ")))
rules.add(AddField("storageId", storageId))
rules.add(AddField("item_type", itemType))
rules.add(AddField("group_access", "guest"))
rules.add(AddField("item_class", "document"))

rules.add(AddField("repository_name", params["repository.name"]))
rules.add(AddField("repository_type", params["repository.type"]))

#indexer.registerNamespace("rdf", "http://www.w3.org/1999/02/22-rdf-syntax-ns#")
#indexer.registerNamespace("rdfs", "http://www.w3.org/2000/01/rdf-schema#")
#indexer.registerNamespace("dc", "http://purl.org/dc/elements/1.1/")
#indexer.registerNamespace("foaf", "http://xmlns.com/foaf/0.1/")
#indexer.registerNamespace("openofficens", "urn:oasis:names:tc:opendocument:xmlns:meta:1.0/")
#indexer.registerNamespace("nie", "http://www.semanticdesktop.org/ontologies/2007/01/19/nie#")
#indexer.registerNamespace("nco", "http://www.semanticdesktop.org/ontologies/2007/03/22/nco#")
#indexer.registerNamespace("nfo", "http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#")
#indexer.registerNamespace("oai_dc", "http://www.openarchives.org/OAI/2.0/oai_dc/")
#indexer.registerNamespace("dcterms", "http://purl.org/dc/terms/")

titleList = []
descriptionList = []
creatorList = []
creationDate = []
contributorList = [] 
approverList = []  
formatList = []
fulltext = []
relationDict = {}
########### 
### Check if dc.xml returned from ice is exist or not. if not... process the dc-rdf

dcPayload = object.getPayload("dc.xml")

if dcPayload is not None:
    dcXml = indexer.getXmlDocument(dcPayload)
    if dcXml is not None:
        #get Title
        titleList = getNodeValues(dcXml, "//*[local-name()='title']")
        
        #get abstract/description 
        descriptionList = getNodeValues(dcXml, "//*[local-name()='description']")
        
        #get creator
        creatorList = getNodeValues(dcXml, "//*[local-name()='creator']")
        

 
        #"""//*[local-name()='relation[starts-with(.,"usq-responsible-officer::")]']""")
        relationList = getNodeValues(dcXml, "//*[local-name()='relation']")
        currentKey = ""
       
        for relation in relationList:
            key, value = relation.split("::")
            value = value.strip()
            key = key.replace("_5f","") #ICE encoding _ as _5f?

            if relationDict.has_key(key):
                relationDict[key].append(value)
            else:
                relationDict[key] = [value]

        #get contributor list
        contributorList = getNodeValues(dcXml, "//*[local-name()='contributor']")
        
        #get creation date 
        creationDate = getNodeValues(dcXml, "//*[local-name()='issued']")


rdfPayload = object.getMetadata()
if rdfPayload is not None:
    rdfModel = indexer.getRdfModel(rdfPayload)
    
    #Seems like aperture only encode the spaces. Tested against special characters file name
    #and it's working 
    rdfId = "file:%s" % object.getId().replace(" ", "%20")
    
    #Set write to False so it won't write to the model
    paginationTextDocument = PaginatedTextDocument(rdfModel, rdfId, False)
    informationElement = InformationElement(rdfModel, rdfId, False)
    
    #1. get title only if no title returned by ICE
    if titleList == []:
        allTitles = informationElement.getAllTitle();
        while (allTitles.hasNext()):
            titleList.append(allTitles.next())
    
    #2. get creator only if no creator returned by ICE
    if creatorList == []:
        allCreators = paginationTextDocument.getAllCreator();
        while (allCreators.hasNext()):
            thing = allCreators.next()
            contacts = Contact(rdfModel, thing.getResource(), False)
            allFullnames = contacts.getAllFullname()
            while (allFullnames.hasNext()):
                 creatorList.append(allFullnames.next())
    
    #3. getFullText: only aperture has this information
    if informationElement.hasPlainTextContent():
        allPlainTextContents = informationElement.getAllPlainTextContent()
        while(allPlainTextContents.hasNext()):
            fulltextString = allPlainTextContents.next()
            fulltext.append(fulltextString)
            
            #4. description/abstract will not be returned by aperture, so if no description found
            # in dc.xml returned by ICE, put first 100 characters
            if descriptionList == []:
                descriptionString = fulltextString
                if len(fulltextString)>100:
                    descriptionString = fulltextString[:100] + "..."
                descriptionList.append(descriptionString)

    #5. mimeType: only aperture has this information
    if informationElement.hasMimeType():
        allMimeTypes = informationElement.getAllMimeType()
        while(allMimeTypes.hasNext()):
            formatList.append(allMimeTypes.next())

    #6. contentCreated
    if creationDate == []:
        if informationElement.hasContentCreated():
            creationDate.append(informationElement.getContentCreated().getTime().toString())


#Start Indexing....
indexing(["dc_title"], titleList)
indexing(["dc_creator"], creatorList)  #no dc_author in schema.xml, need to check 
indexing(["dc_contributor"], contributorList)

for key in relationDict:
    indexing([key], relationDict[key])


indexing(["dc_description"], descriptionList)
indexing(["dc_format"], formatList)
indexing(["full_text"], fulltext)
indexing(["dc_date"], creationDate)
